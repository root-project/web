# Coding in ROOT with the horsepower of an F1

If you've ever rubbed your eyes trying to decrypt C++ compilation errors from a terminal, tracing those back to the line in the ROOT script you were just typing in your text editor, then googling "CERN ROOT TTree" to fix the signature of that function you just used incorrectly, or even have barely faced the intimidating logs of valgrind output for memory detection, you should definitely keep reading.

## Errors are learning tools, not mistakes

There is a natural tendency to look at compilation or conceptual errors as unwanted accidents or mistakes that only happen rarely, because of my own inexperience, and that surely will not happen next time. As such, we are not explictly prepared nor trained to deal with them systematically. We just tackle them as a contingency and try to solve them quickly with whatever tools at hand. Yet experience tells us that errors (in programming, in mathematics, in jugdment biases) are not an exception, but rather the rule. In fact, most of the time in (robust) development is spent on debugging, either passively by looking at whatever problem pops up, or actively, by creating robust software architecture from its concepation, as well as a suite of tests that prevent these in the future in as many virtual scenarios as possible. It is not uncommon that you can write an analysis software in 5 hours, but then spend 5 days tracking down why the heck it's giving wrong results, or crashing once every 100 times, or even more worryingly, leading you silently to wrong scientific conclusions or errors in other links of your analysis chain, that are far away from its original source and thus hard to trace back.
